   　

# 复杂度

数据结构和算法动态可视化网站：https://visualgo.net/zh

## 什么是算法

算法是用于解决特定问题的一系列的执行步骤

使用不同算法，解决同一个问题，效率可能相差非常大

​     比如：求第n个斐波那契数

1. 递归解法

   ```
   public static int fib1(int n) {
   
           if (n == 0) {
               return 0;
           }
           if (n == 1) {
               return 1;
           }
           return fib1(n-1) + fib1(n-2);
       }
   ```

2. O(n)复杂度写法

   ```
   public static int fib2(int n) {
   
           int first = 0;
           int second = 1;
           int temp = 0;
           for (int i = 0; i< n-1; i++) {
               temp = first+second;
               first = second;
               second = temp;
           }
           return second;
       }
   ```

### 如何评判一个算法的好坏？

一般从以下纬度来评估算法的优劣

1. 基本：正确性、可读性、健壮性(对不合理输入的反应能力和处理能力)
2. 时间复杂度: 估算程序指令的执行次数(执行时间)
3. 空间复杂度: 估算所需占用的存储空间

### 大O表示法

一般用大O表示法来描述复杂度，它表示的是数据规模n对应的复杂度

忽略常数、系数、低阶

1. 9 >>> O(1)
2. 2n+3 >>> O(n)
3. n^2 + 2n + 6 >>>> O(n^2)
4. 4n^3 + 3n^2+22n+100 >>> O(n^3)

#### 对数阶的细节

对数阶一般省略底数

Log2(n) = log2(9) * log9(n)

所以Log2(n)、log9(n)统称为logn

### 常见的复杂度

![常见的复杂度](/Users/zhousuhua/Desktop/iOS学习/笔记/所有学习笔记/数据结构与算法/常见的复杂度.png)

可以借助函数生成工具对比复杂度的大小

https://zh.numberempire.com/graphingcalculator.php

### 算法优化方向

#### 用尽量少的存储空间

#### 用尽量少的执行步骤(执行时间)

#### 根据情况，可以

##### 空间换时间

##### 时间换空间

#### %运算符优化

尽量避免使用乘*、除/、摸%、浮点数运算，效率低下

### 复杂度分析

#### 最好情况复杂度

#### 最坏情况复杂度

#### 平均情况复杂度

#### 均摊复杂度

经过连续的多次复杂度比较低的情况后，出现个别复杂度高的情况下，可以考虑用均摊复杂度





## 什么是数据结构

数据结构是计算机存储、组织数据的方式

1. 线性结构
   1. 线性表(数组、链表、栈、队列、哈希表)
2. 树形结构
   1. 二叉树
   2. AVL树
   3. 红黑树
   4. B树
   5. 堆
   6. Trie
   7. 哈夫曼树
   8. 并查集
3. 图形结构
   1. 领接矩阵
   2. 领接表

### 线性表

线性表是具有n个相同类型元素的有限序列(n>=0)

#### 数组

数组是一种顺序存储的线性表，所有元素的内存地址是连续的

栈空间array对象，指向了堆空间的值

##### 动态数组

在很多编程语言中，数组都有个致命的缺点: 无法动态修改容量

实际开发中，我们更希望数组的容量是可以动态改变的! 

![动态数组接口设计](/Users/zhousuhua/Desktop/iOS学习/笔记/所有学习笔记/数据结构与算法/动态数组接口设计.png)

注意: 如果动态数组存的是int值，存的就是内容，由于数组占用内存已经申请下来了，那么清空数组，对应位置的值可以不用清除，只要让外界不能访问到就行，这样可以省去清空数组的值所花的时间

但是如果动态数组存的是对象，那么存的是对象的地址值，也就是引用，删除数组里的数据不是更改能访问的size大小就可以，而是需要将对应位置的值清除，这样对象才能销毁

java的JDK中也内置了动态数组类: java.util.ArrayList // 

###### 动态数组的缩容

如果内存使用比较紧张，动态数组有比较多的剩余空间，可以考虑进行缩容操作: 比如剩余空间占总容量的一半时，就进行缩容

如果扩容倍数，缩容时机设计不得当，有可能会导致复杂度震荡

#### 链表

动态数组有个明显的缺点，可能会造成内存空间的大量浪费，

##### 单向链表

链表是一种链式存储的线性表，所有元素的内存地址不一定是连续的

##### ![链表的设计](/Users/zhousuhua/Desktop/iOS学习/笔记/所有学习笔记/数据结构与算法/链表的设计.png)

###### 快慢指针

定义2个指针，一个快指针，一个慢指针，快指针每次移动2步，慢指针每次移动一步，每移动一次时，快指针和慢指针的距离就近一步，最终总会相遇，leetcode的判断是否是环形链表，链表的中间节点就可以用快慢指针解决

###### 虚拟头节点

有时候为了让代码更加精简，统一所有节点的处理逻辑，可以在最前面增加一个虚拟的头结点(不存储数据)

###### 动态数据、链表复杂度分析

![动态数组、链表复杂度分析](/Users/zhousuhua/Desktop/iOS学习/笔记/所有学习笔记/数据结构与算法/动态数组、链表复杂度分析.png)

动态数组add(E element)方法复杂度分析

```
// 复杂度 最好 O(1)  最坏是扩容的时候，扩容方法 O(n)  平均 O(1)+O(1)+...O(1)+O(n) == O(1)
/*
  均摊复杂度: O(n)平均到之前的每个O(1)上，那么之前的O(1)其实是O(2),O(2)也是用O(1)来表示
  均摊复杂度: 经过连续的多次复杂度比较低的情况后，出现个别复杂度高的情况
 */
```

##### 双向链表

![双向链表](/Users/zhousuhua/Desktop/iOS学习/笔记/所有学习笔记/数据结构与算法/双向链表.png)

###### 双向链表 VS 单向链表

![双向链表vs单向链表](/Users/zhousuhua/Desktop/iOS学习/笔记/所有学习笔记/数据结构与算法/双向链表vs单向链表.png)

###### 双向链表 VS 动态数组

![双向链表vs动态数组](/Users/zhousuhua/Desktop/iOS学习/笔记/所有学习笔记/数据结构与算法/双向链表vs动态数组.png)

##### 单向循环链表

就是单向链表的last的next指向了first，形成一个循环圈

##### 双向循环链表

就是双向链表的last的next指向了first，first的pre指向last，形成一个循环圈

###### 发挥循环链表的最大威力

增加一个current结点，和3个方法，reset()//将current指向头结点，next()//current往后挪一步，

remove()// 删除current指定的结点，删除成功后让current指向下一个结点

约瑟夫问题通过current和这3个方法就可以很好解决

##### 静态链表

前面所说的链表，是依赖指针实现的，有些编程语言是没有指针的，比如早期的BASIC、FORIRAN语言，没有指针的情况下可以通过数组模拟链表，称为静态链表

数组每个位置下放2个元素(比如说数组里放结构体c++语言)，一个元素是值，linge另一个元素是下个元素的索引

或者用2个数组实现，一个数组专门放索引，一个专门存放值

#### 栈

栈是一种后进先出的特殊线性表，只能在一端操作

应用：浏览器的前进和后退功能，就是用了2个栈，一个存放已经前进的栈数据，一个存放着已经后退的数据，当点击后退时，从前进栈里pop栈顶元素，再将这个元素放入后退栈，点击前进时，从后退栈pop出元素入栈到前进栈里， 软件的撤销、恢复都是用栈实现

#### 队列

##### 队列

队列是一种特殊的线性表，只能在头尾两端进行操作，先进先出

队尾(rear)： 只能从队尾添加元素，一般叫做enQueue,入队

队头(front)： 只能从队头移除元素，一般叫做deQueue,出队

##### 双端队列（Deque）

双端队列是能在头尾两端添加、删除的队列

##### 循环队列

循环队列:  

用数组实现循环队列思路: 用front记录首位置，根据队列先进先出原则，删除一个元素时候将front往后挪一位，比如之前front是索引0，此时到索引1，再删除一个元素，front变成索引2，添加元素时，从数组尾部添加，填到最后一个位置时候，可以将元素添加到0，1位置(因为此时0和1位置并没有存储数据)，这样就叫做循环队列

当数组每个位置都存满后，就扩容，从front开始将数组放到新数组下，在新数组下，front又变成了0，

##### 循环两端队列

2端都可以添加删除，注意前端添加时候，front往前挪，front如果是0的话，由于是循环的，所以front为数组的长度-1位置

注意计算正确前后端添加删除，size大小，front位置

### 二叉树

二叉树: 二叉树(binary tree) 是一种树型结构，它的特点是每个结点至多只有二棵子树(即二叉树中不存在度大于2的结点)

       1. 每个节点的度最大为2(最多拥有2颗子树)
          2. 左子树和右子树是有顺序的
          3. 即使某节点只有一棵子树，也要区分左右子树
          4. 二叉树是有序树

多叉树:  树中存在度大于2的结点

#### 基本概念

1. 节点、跟节点、父节点、子节点、兄弟节点

2. 一棵树可以没有任何节点，称为空树

3. 一棵树可以只有强哥节点，也就是只有根节点

4. 子树、左子树、右子树
5.  
6. 节点的**度(degree)**：子树的个数
7. 树的**度(degree)**：所有节点度中的最大值
8. **叶子节点(leaf)**: 度为0的节点
9. **非叶子节点**:度不为0的节点
10.  
11. **层数(level)**: 根节点在第一层，根节点的子节点在第2层，以此类推(有些教程也从第0层开始计算)
12. **节点的深度(depth)**：从根节点到当前节点的唯一路径上的节点总数
13. **节点的高度(height)**：从当前节点到最远叶子节点的路径上的节点总数
14. **树的深度**:所有节点深度中的最大值
15. **树的高度**:所有节点高度中的最大值
16. **树的深度等于树的高度**
17.  

##### 有序树、无序树、森林

1. 有序树: 树中任意节点的子节点之间有顺序关系
2. 无序树:树中任意节点的子节点之间没有顺序关系，也称为“自由树”
3. 森林: 由m(m >= 0)课互不相交的树组成的集合

##### 二叉树的性质

1. 非空二叉树的第i层，最多有2^(i-1)个节点(i >= 1),  //（从第一层开始算，第一层1个，第二层2个，三层4个........）
2. 在高度为h的二叉树上最多有2^h - 1个节点(h >= 1)  // (第一层的节点+第二层的+...+第h层： 2^0+2^1+2^2+2^3+.....2^(h-1) = 2^h - 1)
3. 对于任何一颗非空二叉树，如果叶子节点个数为n0，度为2的节点个数为n2，则有n0=n2+1
   1. 证明: 假设度为1的节点个数为n1，那么二叉树的节点总数n=n0+n1+n2
   2. 二叉树的边树T=n0 * 0 + n1 * 1 + n2 * 2 
   3. 又由于边树和n的关系是 T=n-1 // （只有一个根节点时不会有边，加一个节点后，就会产生一条边，之后每增加一个节点，就会产生一条边，所以边树=节点总数-1）
   4. 所以T=n0 * 0 + n1 * 1 + n2 * 2 =n-1=n0+n1+n2-1
   5. 进一步 n1 * 1 + n2 * 2 = n0+n1+n2-1
   6. 得出n0=n2+1

##### 几种二叉树

###### 真二叉树(国外教材的完满二叉树Full Binary Tree)

所有节点的度都要么为0，要么为2

###### 满二叉树(国外教材的完美二叉树Perfect Binary Tree)

所有节点的度都要么为0，要么为2，且所有的叶子节点都在最后一层

###### 满二叉树的性质

假设满二叉树的高度为h(h >= 1),那么

1. 第i层的节点数量: 2^(i-1)
2. 叶子节点数量: 2^(h-1)
3. 总节点数量 n=2^h-1 得出 h=log2(n+1)
4. 在同样高度的二叉树中，满二叉树的叶子节点数量最多，总节点数量最多
5. 满二叉树一定是真二叉树，真二叉树不一定是满二叉树

###### 完全二叉树(国外教材也叫完全二叉树Complete Binary Tree)

叶子节点只会出现在最后2层，且最后一层的叶子结点都靠左对齐

完全二叉树丛根节点至倒数第2层是一颗满二叉树

满二叉树一定是完全二叉树，完成二叉树不一定是满二叉树

###### 完全二叉树的性质

1. 度为1的节点只有左子树
2. 度为1的节点要么是一个，要么是0个
3. 同样节点高度数量的二叉树，完全二叉树的高度最小

假设完成二叉树的高度为h(h>=1)

1. 至少有2^(h-1)个节点(2^0+2^1+2^2+....+2^(h-2)+1)
2. 最多有2^h-1个节点(2^0+2^1+2^2+....+2^(h-1)即满二叉树)
3. 总节点数量为n
   1. 2^(h-1)<=n<2^h
   2. h-1<=log2n<h
   3. h=floor(log2n)+1 // 一般代码里默认是floor
   4. floor向下取整，取整数部分的值，ceiling是向上取整，整数部分的值+小数部分有值?小数部分有值:0
4.  ![完全二叉树的性质2](/Users/zhousuhua/Desktop/iOS学习/笔记/所有学习笔记/数据结构与算法/完全二叉树的性质2.png)
5. 

![完全二叉树的性质3](/Users/zhousuhua/Desktop/iOS学习/笔记/所有学习笔记/数据结构与算法/完全二叉树的性质3.png)

###### 完成二叉树面试题

如果一颗完全二叉树有768个节点，求叶子节点的个数

1. 假设叶子节点个数为n0，度为1的节点个数为n1，度为2的节点个数为n2
2. 总节点个数n=n0+n1+n2,而且n0=n2+1 （上面证明过）
3. 所以 n=2n0+n1-1
4. 由于完全二叉树的n1要么为0，要么为1
5. 当n1为1时，由于第三条可知n=2n0,n必然是偶数
6. 叶子节点(即度为0)个数n0=n/2,那么非叶子节点个数n1+n2=n-n/2
7. 当n1为0时，由于第三条可知n=2n0-1,n必然是奇数
8. 叶子节点(即度为0)个数n0=(n+1)/2,那么非叶子节点个数n1+n2=(n-1)/2
9. 总结:
10. 叶子节点个数n0=floor((n+1)/2) = ceiling(n/2)
11. 非叶子节点个数n1+n2=floor(n/2) = ceiling((n-1)/2)
12. 因此叶子节点个数为384

##### 二叉树的遍历

线性数据结构的遍历比较简单

1. 正虚遍历
2. 逆序遍历

二叉树的遍历: 根据节点访问顺序的不同，二叉树的常见遍历方法为:

1. 前序遍历(Preorder Traversal):  先访问根节点，前序遍历左子树，前序遍历右子树(即对左右子树而言，它也是符合前序遍历规则的，即访问自己，再访问自己的左子树，再右子树)

2. 中序遍历(Inorder Traversal)： 指根节点在第二位访问，又细分为先中序左子树、根节点、中序右子树 或者 中序右子树、根节点、中序左子树。所以可知二叉搜索树的中序遍历结果是升序或者降序的

3. 后序遍历(Postorder Traversal)： 后序遍历左子树、后序遍历右子树、根节点

4. 层序遍历(Level Order Traversal)：从上到下、从左到右依次访问每一个节点

   实现思路: 使用队列

   1. 将根节点入队
   2. 循环执行以下操作，直到队列为空
      1. 将队头节点A出队，进行访问
      2. 将A的左子节点入队
      3. 将A的右子节点入队

####  

###### 前驱节点

中序排序时该节点的前一个节点叫前驱节点，比如下图6的前驱节点是5，12的前驱节点是11

![前驱节点](/Users/zhousuhua/Desktop/iOS学习/笔记/所有学习笔记/数据结构与算法/前驱节点.png)



###### 后继节点

中序排序时该节点的后一个节点叫后继节点，比如下图6的后继节点是7，12的后继节点是13

![后继节点](/Users/zhousuhua/Desktop/iOS学习/笔记/所有学习笔记/数据结构与算法/后继节点.png)

#### 二叉搜索树

二叉搜索树又称为二叉查找树、二叉排序树，英文简称BST

特点

	1. 任意一个节点的值都大于其左子树所有节点的值
 	2. 任意一个节点的值都小于其右子树所有节点的值
 	3. 它的左右子树也是一颗二叉搜索树

二叉搜索树可以大大提高搜索数据的效率

二叉搜索树存储的元素必须具备可比较性(比如int、double等，如果是自定义类型，需要制定比较方式，不允许为null)

##### 平衡二叉搜索树

###### 二叉树的复杂度分析

![二叉树的复杂度分析](/Users/zhousuhua/Desktop/iOS学习/笔记/所有学习笔记/数据结构与算法/二叉树的复杂度分析.png)

###### 平衡

![平衡](/Users/zhousuhua/Desktop/iOS学习/笔记/所有学习笔记/数据结构与算法/平衡.png)

###### 理想平衡

最理解的平衡，就是像完全二叉树、满二叉树那样，高度是最小的

###### 改进二叉搜索树

总结来说,比较合理的改进方案是:用尽量少的调整次数达到适度平衡即可

一颗达到适度平衡的二叉搜索树，可以称之为: 平衡二叉搜索树

###### 常见的平衡二叉搜索树

一般也称它们为: 自平衡的二叉搜索树

1. AVL树 ： Windows NT 内核中广泛使用
2. 红黑树:
   1.  C++ STL(比如map、Set)，
   2. java的TreeMap、TreeSet、HashMap、HashSet、
   3. Linux的进程调度、
   4. Ngix的timer管理

##### AVL树

平衡因子: 某节点的左右子树的高度差

AVL树的特点

1. 每个节点的平衡因子只可能是1、0、-1(绝对值<=1,如果超过1，称之为"失衡")
2. 每个节点的左右子树高度差不超过1
3. 搜索、添加、删除的时间复杂度O(logn)

添加导致的失衡

​    最坏情况: 可能会导致所有祖先节点都失衡，但是只要让高度最低的失衡节点恢复平衡，整棵树就恢复平衡(仅需O(1)次调整)

​    父节点、非祖先节点都不可能失衡

删除导致的失衡

​      可能会导致父节点或者祖先节点失衡

​      恢复平衡后，可能会导致更高层的祖先节点失衡(最多需要O(logn)次调整)

平均时间复杂度

1. 搜索: O(logn)
2. 添加: O(logn)，仅需O(1)次的旋转操作
3. 删除: O(lögn),最多需要O(logn)次的旋转操作

###### LL-右旋转(单旋)

![LL](/Users/zhousuhua/Desktop/iOS学习/笔记/所有学习笔记/数据结构与算法/LL.png)

###### RR-左旋转(单旋)

![RR](/Users/zhousuhua/Desktop/iOS学习/笔记/所有学习笔记/数据结构与算法/RR.png)

###### LR-RR左旋转，LL右旋转(双旋)

![LR](/Users/zhousuhua/Desktop/iOS学习/笔记/所有学习笔记/数据结构与算法/LR.png)

###### RL-LL右旋转,RR左旋转(双旋)

![RL](/Users/zhousuhua/Desktop/iOS学习/笔记/所有学习笔记/数据结构与算法/RL.png)
















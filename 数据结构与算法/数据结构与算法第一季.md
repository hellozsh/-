   　

# 复杂度

数据结构和算法动态可视化网站：https://visualgo.net/zh

## 什么是算法

算法是用于解决特定问题的一系列的执行步骤

使用不同算法，解决同一个问题，效率可能相差非常大

​     比如：求第n个斐波那契数

1. 递归解法

   ```
   public static int fib1(int n) {
   
           if (n == 0) {
               return 0;
           }
           if (n == 1) {
               return 1;
           }
           return fib1(n-1) + fib1(n-2);
       }
   ```

2. O(n)复杂度写法

   ```
   public static int fib2(int n) {
   
           int first = 0;
           int second = 1;
           int temp = 0;
           for (int i = 0; i< n-1; i++) {
               temp = first+second;
               first = second;
               second = temp;
           }
           return second;
       }
   ```

### 如何评判一个算法的好坏？

一般从以下纬度来评估算法的优劣

1. 基本：正确性、可读性、健壮性(对不合理输入的反应能力和处理能力)
2. 时间复杂度: 估算程序指令的执行次数(执行时间)
3. 空间复杂度: 估算所需占用的存储空间

### 大O表示法

一般用大O表示法来描述复杂度，它表示的是数据规模n对应的复杂度

忽略常数、系数、低阶

1. 9 >>> O(1)
2. 2n+3 >>> O(n)
3. n^2 + 2n + 6 >>>> O(n^2)
4. 4n^3 + 3n^2+22n+100 >>> O(n^3)

#### 对数阶的细节

对数阶一般省略底数

Log2(n) = log2(9) * log9(n)

所以Log2(n)、log9(n)统称为logn

### 常见的复杂度

![常见的复杂度](/Users/zhousuhua/Desktop/iOS学习/笔记/所有学习笔记/数据结构与算法/常见的复杂度.png)

可以借助函数生成工具对比复杂度的大小

https://zh.numberempire.com/graphingcalculator.php

### 算法优化方向

1. 用尽量少的存储空间
2. 用尽量少的执行步骤(执行时间)
3. 根据情况，可以
   1. 空间换时间
   2. 时间换空间

### 复杂度分析

#### 最好情况复杂度

#### 最坏情况复杂度

#### 平均情况复杂度

#### 均摊复杂度

经过连续的多次复杂度比较低的情况后，出现个别复杂度高的情况下，可以考虑用均摊复杂度





## 什么是数据结构

数据结构是计算机存储、组织数据的方式

1. 线性结构
   1. 线性表(数组、链表、栈、队列、哈希表)
2. 树形结构
   1. 二叉树
   2. AVL树
   3. 红黑树
   4. B树
   5. 堆
   6. Trie
   7. 哈夫曼树
   8. 并查集
3. 图形结构
   1. 领接矩阵
   2. 领接表

### 线性表

线性表是具有n个相同类型元素的有限序列(n>=0)

#### 数组

数组是一种顺序存储的线性表，所有元素的内存地址是连续的

栈空间array对象，指向了堆空间的值

##### 动态数组

在很多编程语言中，数组都有个致命的缺点: 无法动态修改容量

实际开发中，我们更希望数组的容量是可以动态改变的! 

![动态数组接口设计](/Users/zhousuhua/Desktop/iOS学习/笔记/所有学习笔记/数据结构与算法/动态数组接口设计.png)

注意: 如果动态数组存的是int值，存的就是内容，由于数组占用内存已经申请下来了，那么清空数组，对应位置的值可以不用清除，只要让外界不能访问到就行，这样可以省去清空数组的值所花的时间

但是如果动态数组存的是对象，那么存的是对象的地址值，也就是引用，删除数组里的数据不是更改能访问的size大小就可以，而是需要将对应位置的值清除，这样对象才能销毁

java的JDK中也内置了动态数组类: java.util.ArrayList // 

###### 动态数组的缩容

如果内存使用比较紧张，动态数组有比较多的剩余空间，可以考虑进行缩容操作: 比如剩余空间占总容量的一半时，就进行缩容

如果扩容倍数，缩容时机设计不得当，有可能会导致复杂度震荡

#### 链表

动态数组有个明显的缺点，可能会造成内存空间的大量浪费，

链表是一种链式存储的线性表，所有元素的内存地址不一定是连续的

##### ![链表的设计](/Users/zhousuhua/Desktop/iOS学习/笔记/所有学习笔记/数据结构与算法/链表的设计.png)

##### 快慢指针

定义2个指针，一个快指针，一个慢指针，快指针每次移动2步，慢指针每次移动一步，每移动一次时，快指针和慢指针的距离就近一步，最终总会相遇，leetcode的判断是否是环形链表，链表的中间节点就可以用快慢指针解决

##### 虚拟头节点

有时候为了让代码更加精简，统一所有节点的处理逻辑，可以在最前面增加一个虚拟的头结点(不存储数据)

##### 动态数据、链表复杂度分析

![动态数组、链表复杂度分析](/Users/zhousuhua/Desktop/iOS学习/笔记/所有学习笔记/数据结构与算法/动态数组、链表复杂度分析.png)

动态数组add(E element)方法复杂度分析

```
// 复杂度 最好 O(1)  最坏是扩容的时候，扩容方法 O(n)  平均 O(1)+O(1)+...O(1)+O(n) == O(1)
/*
  均摊复杂度: O(n)平均到之前的每个O(1)上，那么之前的O(1)其实是O(2),O(2)也是用O(1)来表示
  均摊复杂度: 经过连续的多次复杂度比较低的情况后，出现个别复杂度高的情况
 */
```

#### 双向链表

![双向链表](/Users/zhousuhua/Desktop/iOS学习/笔记/所有学习笔记/数据结构与算法/双向链表.png)

##### 双向链表 VS 单向链表

![双向链表vs单向链表](/Users/zhousuhua/Desktop/iOS学习/笔记/所有学习笔记/数据结构与算法/双向链表vs单向链表.png)

##### 双向链表 VS 动态数组

![双向链表vs动态数组](/Users/zhousuhua/Desktop/iOS学习/笔记/所有学习笔记/数据结构与算法/双向链表vs动态数组.png)

#### 单向循环链表

就是单向链表的last的next指向了first，形成一个循环圈

#### 双向循环链表

就是双向链表的last的next指向了first，first的pre指向last，形成一个循环圈


---
typora-root-url: ../../StudyNotes
---

[TOC]

# Runtime



# 多线程

## 面试题

1. 你理解的多线程？
2. iOS的多线程方案有哪几种？你更倾向于哪一种？
3. 你在项目中用过 GCD 吗？GCD 的队列类型
4. 说一下 OperationQueue 和 GCD 的区别，以及各自的优势
5. 线程安全的处理手段有哪些？
6. OC你了解的锁有哪些？在你回答基础上进行二次提问；
   1. 追问一：自旋和互斥对比？
   2. 追问二：使用以上锁需要注意哪些？
   3. 追问三：用C/OC/C++，任选其一，实现自旋或互斥？口述即可！

## 什么是多线程

OS X和iOS的核心XNU内核在发生操作系统事件时(如每隔一段时间，唤起系统调用等情况)会切换执行路径。执行中路径的状态，例如CPU的寄存器等信息保存到各自路径专用的内存块中，从切换目标路径专用的内存块中，复原CPU寄存器等信息，继续执行切换路径的CPU命令行。这就被称为"上下文切换"

​	由于使用多线程的程序可以在某个线程和其他线程之间反复多次进行上下文切换，因此看上去就好像1个CPU核能够并列地执行多个线程一样。而且在具有多个CPU核的情况下，就不是"看上去像"了，而是真的提供了多个CPU核并行执行多个线程的技术

​	这种利用多线程编程的技术就被称为“多线程编程”。

## GCD

### Dispatch Queue

执行处理的等待队列。应用程序编程人员通过dispatch_async函数等API，在Block语法中记述想执行的处理并将其追加到Dispatch Queue中，Dispatch Queue按照追加的顺序(先进先出FIFO)执行处理。

#### 串行队列(Serial Dispatch Queue)

因为要等待现在执行中的处理结束，所以首先执行blk0，blk0执行结束后，接着执行blk1，blk1结束后再开始执行blk2，如此重复。同时执行的处理数只能有1个。

#### 并发队列(Concurrent Dispatch Queue)

因为不用等待现在执行中的处理结束，所以首先执行blk0，不管blk0的执行是否结束，都开始执行后面的blk1，不管blk1的执行是否结束，都开始执行后面的blk2，如此重复循环

​	这样虽然不用等待处理结束，可以并行执行多个处理，但并行执行的处理数量取决于当前系统的状态。即iOS和OS X基于Dispatch Queue中的处理数，CPU核数以及CPU负荷等当前系统的状态来决定并发队列中并行执行的处理数

​	iOS和OS X的核心——XNU内核决定应当使用的线程数，并只生成所需的线程执行处理。另外，当处理结束，应当执行的处理数减少时，XNU内核会结束不再需要的线程。

​	假设准备4个Concurrent Dispatch Queue用线程，首先blk0再线程0中开始执行，接着blk1在线程1中、blk2在线程2中、blk3在线程3中开始执行。线程0中blk0执行结束后开始执行blk4，由于线程1中blk1的执行没有结束，因此线程2中blk2执行结束后开始执行blk5，就这样循环往复



## 线程的定义

+ <font color=#FF0000 >线程是进程的基本执行单元</font>，一个进程的所有任务都在线程中执行
+ 进程要想执行任务，必须得有线程，进程至少要有一条线程
+ <font color=#FF0000 >程序启动会默认开启一条线程</font>，这条线程被称为主线程或UI线程

## 进程的定义

+ 进程是指在系统中正在运行的一个应用程序
+ 每个进程之间是独立的，每个进程均运行在其专用的且受保护的内存

## 进程与线程的关系

+ 地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间
+ 资源拥有：同一进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的资源是独立的。
+ 执行过程：每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
+ 线程是处理器调度的基本单位，但是进程不是。

## 多线程的意义

+ 优点

  + 能适当提高程序的执行效率
  + 能适当提高资源的利用率（CPU，内存）
  + 线程上的任务执行完成后，线程会自动销毁

+ 缺点

  + 开启线程需要占用一定的内存空间（默认情况下，每一个线程都占 512 KB）[^表现]

  + 如果开启大量的线程，会占用大量的内存空间，降低程序的性能

  + 线程越多，CPU 在调用线程上的开销就越大

  + 程序设计更加复杂，比如线程间的通信、多线程的数据共享

    [^表现]:主线程开一个线程里输出一个打印，再在主线程输出一个打印，先调用的是后面主线程的这个打印，因为开线程有一定的耗时

## 多线程的原理

+ 多线程指的是多个线程"同时"执行[^同时]

+ Oc项目启动时，系统会自己开辟好几个线程，用于他的操作，我们可以给线程设置名字用于区分功能

  [^同时]: 1个CPU核一次能执行的CPU命令始终为1，使用多线程的程序可以在某个线程和其他线程之间反复多次进行上下文切换，因此看上去就好像1个CPU核能够并列地执行多个线程一样

### 多线程技术方案

| 方案        | 简介                                                         | 语言 | 线程生命周期 | 使用频率 |
| ----------- | ------------------------------------------------------------ | ---- | ------------ | -------- |
| pthread     | 1.一套通用的多线程API<br/>2.适用于Unix\Linux\Windows等系统<br/>3.跨平台\可移植<br/>4.使用难度大 | C    | 程序员管理   | 几乎不用 |
| NSThread    | 1.使用更加面向对象<br/>2.简单易用，可直接操作线程对象        | OC   | 程序员管理   | 偶尔使用 |
| GCD         | 1.旨在替代NSThread等线程技术<br/>2.充分利用设备的多核        | C    | 自动管理     | 经常使用 |
| NSOperation | 1.基于GCD<br/>2.比GCD多了一些更简单实用的功能<br/>3.使用更加面向对象 | OC   | 自动管理     | 经常使用 |

NSThread、GCD、NSOperation底层都是用的pthread

###多线程生命周期![多线程生命周期](/Oc进阶项目实战笔记/多线程生命周期.png)

### 线程池原理

![饱和策略](/Oc进阶项目实战笔记/饱和策略.png)

### GCD的常用函数

+ GCD中有2个用来执行任务的函数

  +  用同步的方式执行任务

    dispatch_<font color=#FF0000 >sync</font>(dispatch_queue_t queue, dispatch_block_t block);

    queue： 队列 

    Block: 任务

  + 用异步的方式执行任务

    dispatch_<font color=#FF0000 >async</font>(dispatch_queue_t queue, dispatch_block_t block); 

### 锁

#### 自旋锁

转转-忙等-用于代码较小耗时较少

#### 互斥锁

打盹-睡觉-

##递归非递归

#### 读写锁

多读单写

写影响读，读不影响写

### atomic与nonatomic 的区别

+ nonatomic 非原子属性， 非线程安全，适合内存小的移动设备
  + 保证同一时间只有一个线程能够写入(但是同一个时间多个线程都可以取值)
  + atomic 本身就有一把锁(自旋锁)
  + 单写多读：单个线程写入，多个线程可以读取 
+ atomic 原子属性(线程安全)，针对多线程设计的，默认值， 线程安全，需要消耗大量的资源

### 线程和Runloop的关系

1. runloop与线程是一一对应的，一个runloop对应一个核心的线程，为什么说是核心的，是因为runloop是可以嵌套的，但是核心的只能有一个，他们的关系保存在一个全局的字典里。
2. runloop是来管理线程的，当线程的runloop被开启后，线程会在执行完任务后进入休眠状态，有了任务就会被唤醒去执行任务。
3. runloop在第一次获取时被创建，在线程结束时被销毁。
4. 对于主线程来说，runloop在程序一启动就默认创建好了。
5. 对于子线程来说，runloop是懒加载的，只有当我们使用的时候才会创建，所以在子线程用定时器要注意：确保子线程的runloop被创建，不然定时器不会回调。

runloop = dict[key 线程指针]，runloop的执行是建立在线程上面的，线程的执行和runloop没有关系，runloop没建立，线程也可以执行，runloop可以保证线程不退出，常驻线程，而time计时器需要依赖runloop，所以在子线程使用定时器时，需要先确保子线程的runloop被创建

创建线程[ [NSRunLoop currentRunLoop] run]



##等source



##异步渲染

## 优先级反转

https://www.jianshu.com/p/c557308c0ec5

http://zenonhuang.me/2018/03/08/technology/2018-03-01-LockForiOS/